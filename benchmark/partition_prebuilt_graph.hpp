#include <immintrin.h> // needed to include this to make sure that the code compiles since in DiskANN/include/utils.h it uses this library.
#include "defaults.h"
#include "defs.h"
#include "distance.h"
#include "linux_aligned_file_reader.h"
#include "metis_io.h"
#include "partitioning.h"
#include "pq_flash_index.h"
#include <boost/program_options.hpp>
#include <cascade/service_client_api.hpp>
#include <fstream>
#include <iostream>
#include <libaio.h>
#include <omp.h>
#include <stdexcept>
#include <utils/graph.h>


#define NUM_THREADS 16
#define WHOLE_GRAPH_SUBGROUP_INDEX 0
#define MAX_DEGREE 128

using namespace derecho::cascade;
using namespace parlayANN;

AdjGraph convert_graph_to_adjgraph(Graph<unsigned int> &G);
Clusters get_clusters_from_adjgraph(AdjGraph &adj, int num_clusters);
/**
   index_prefix_path: prefix to the index and the rest of the data generated by
   building an ssd diskann index
   coord_buffers
 */

template <typename data_type> struct vector_data {
  std::unique_ptr<data_type[]> embedding;
  std::unique_ptr<std::pair<uint32_t, uint32_t[]>> neighbors;
};

template <typename data_type>
void load_diskann_graph_into_cascade(
				     ServiceClientAPI &capi,
				     const std::unique_ptr<diskann::PQFlashIndex<data_type>> &_pFlashIndex,
				     const Clusters &clusters,
				     int max_degree)
{
  int dimension = _pFlashIndex->get_data_dim();
  for (int i = 0; i < clusters.size(); i++) {
    std::string cluster_folder = "/anns/cluster_" + std::to_string(i);
    capi.template create_object_pool<VolatileCascadeStoreWithStringKey>(cluster_folder, WHOLE_GRAPH_SUBGROUP_INDEX, HASH, {}, "cluster[0-9]+");

    
    data_type* coord_ptr = new data_type[dimension * clusters[i].size()];
    std::vector<data_type *> tmp_coord_buffer;

    std::vector<std::pair<uint32_t, uint32_t *>> tmp_nbr_buffer;
    uint32_t* neighbors_ptr = new uint32_t[max_degree * clusters[i].size()];

    for (int j = 0; j < clusters[i].size(); j++) {
      tmp_coord_buffer.push_back(coord_ptr + j * dimension);
      tmp_nbr_buffer.emplace_back(0, neighbors_ptr + j * max_degree);
    }

    _pFlashIndex->read_nodes(clusters[i], tmp_coord_buffer,
                             tmp_nbr_buffer); // after this, all data is in tmp_coord_buffer and tmp_nbr_buffer
    
    parlay::parallel_for(0, clusters[i].size(), [&](size_t j) {
      uint32_t vector_id = clusters[i][j];
      size_t num_byte_emb = sizeof(data_type) * dimension;
      size_t num_byte_neighbors = sizeof(unsigned int) * tmp_nbr_buffer[j].first;
      size_t num_byte_object = num_byte_emb + num_byte_neighbors;
      std::vector<std::byte> data(num_byte_object);
      std::memcpy(data.data(), tmp_coord_buffer[j], num_byte_emb);
      std::memcpy(data.data() + dimension * sizeof(data_type),
                  tmp_nbr_buffer[j].second, num_byte_neighbors);
      ObjectWithStringKey vector_data;
      vector_data.key = cluster_folder + "/vector_" + std::to_string(vector_id);
      vector_data.previous_version = INVALID_VERSION;
      vector_data.previous_version_by_key = INVALID_VERSION;
      vector_data.blob = Blob(reinterpret_cast<const uint8_t*>(data.data()), num_byte_object);
      auto result = capi.put(vector_data, false);
      for (auto &reply_future : result.get()) {
        auto reply = reply_future.second.get();
      }
    });
    std::cout << "Done with cluster " << i << "/" << clusters.size() - 1
    << std::endl;
    for (int j = 0; j < 10; j++) {
      std::cout << tmp_nbr_buffer[j].first<< std::endl;
    }
    delete[] coord_ptr;
    delete[] neighbors_ptr;    
  }
    
}

template <typename data_type>
void convert_diskann_graph_to_adjgraph(
    const std::unique_ptr<diskann::PQFlashIndex<data_type>> &_pFlashIndex,
    AdjGraph &adj, int max_degree) {
  adj = std::move(std::vector<std::vector<int>>(_pFlashIndex->get_num_points()));
  parlay::parallel_for(
      0, _pFlashIndex->get_num_points(), [&](size_t node_index) {
        data_type *coord_ptr = new data_type[_pFlashIndex->get_data_dim()];
        std::vector<data_type *> tmp_coord_buffer;
        tmp_coord_buffer.push_back(coord_ptr);
        std::vector<std::pair<uint32_t, uint32_t *>> tmp_nbr_buffer;

        uint32_t *neighbors_ptr = new uint32_t[max_degree];
        tmp_nbr_buffer.emplace_back(0, neighbors_ptr);

        _pFlashIndex->read_nodes(std::vector<uint32_t>(1, node_index),
                                 tmp_coord_buffer, tmp_nbr_buffer);
        for (int i = 0; i < tmp_nbr_buffer[0].first; i++) {
          adj[node_index].push_back(*(tmp_nbr_buffer[0].second + i));
        }

        delete[] coord_ptr;
        delete[] neighbors_ptr;
      });
}
