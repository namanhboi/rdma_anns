import matplotlib.pyplot as plt
import numpy as np
import os
import sys
os.chdir("/home/nam/workspace/rdma_anns")


# the process function for PipeANN, DiskANN and Starling.
# Input: the raw log file
# Output: a dict with key: system + dataset + threads, value: list of latency, throughput and recall.
def process_pipeann(filename):
    mode_sysname = ["DiskANN", "Starling", "PipeANN", "Coro", "SPANN", "Vamana", "balancebatch", "balanceall", "statesend", "scattergather"]
    key = ""
    ret = {}
    with open(filename, "r") as f:
        mode = 0
        dataset = ""
        for line in f:
            if line.startswith("[REPORT]"):
                split_line = line.split()
                mode = int(split_line[6])
                threads = split_line[10]
                dataset = split_line[11]
                key = mode_sysname[mode] + "_" + dataset + "_" + threads
                ret[key] = []
            else:
                # data.
                try:
                    split_line = [float(x) for x in line.split()]
                    # QPS, latency, recall, L
                    cur_tuple = (split_line[2], split_line[3] / 1000, split_line[-1] / 100, split_line[0])
                    ret[key].append(cur_tuple)
                except:
                    pass
    return ret



# for recall-latency and throughput-recall plot.
def reorganize_data(data_array):
    ret = {}
    for data in data_array:
        for k, v in data.items():
            dataset = k.split("_")[1]
            sysname = k.split("_")[0]
            if dataset not in ret:
                ret[dataset] = {}
            ret[dataset][sysname] = v
    return ret

# This function is generated by Gemini 2.5 Pro Preview 03-25. Thanks, Google!
def plot_lat_acc(data, max_lat, min_recall):
    num_datasets = len(data)
    fig, axes = plt.subplots(nrows=1, ncols=num_datasets, figsize=(5 * num_datasets, 4), squeeze=False)

    if num_datasets == 1:
        axes_flat = [axes[0, 0]]
    else:
        axes_flat = axes.flatten()

    for i, (dataset_name, methods_data) in enumerate(data.items()):
        ax = axes_flat[i]
        for method_name, data_points in methods_data.items():
            x_values = [point[1] for point in data_points if len(point) >= 3]
            y_values = [point[2] for point in data_points if len(point) >= 3]

            if x_values:
                sorted_points = sorted(zip(x_values, y_values))
                x_values_sorted, y_values_sorted = zip(*sorted_points)
                ax.plot(x_values_sorted, y_values_sorted, label=method_name, marker='o', linestyle='-')
            else:
                 print(f"No valid points.")

        ax.set_title(f'{dataset_name}')
        ax.set_xlabel('Latency (ms)')
        ax.set_xlim(0, max_lat)
        ax.set_ylabel('Recall 10@10')
        ax.set_ylim(min_recall, 1.01)
        ax.grid(True)
        ax.legend()

    plt.tight_layout()
    return fig

def plot_tput_acc(data, min_recall):
    num_datasets = len(data)
    fig, axes = plt.subplots(nrows=1, ncols=num_datasets, figsize=(5 * num_datasets, 4), squeeze=False)

    if num_datasets == 1:
        axes_flat = [axes[0, 0]]
    else:
        axes_flat = axes.flatten()

    for i, (dataset_name, methods_data) in enumerate(data.items()):
        ax = axes_flat[i]
        for method_name, data_points in methods_data.items():
            x_values = [point[2] for point in data_points if len(point) >= 3]
            y_values = [point[0] for point in data_points if len(point) >= 3]

            if x_values:
                sorted_points = sorted(zip(x_values, y_values))
                x_values_sorted, y_values_sorted = zip(*sorted_points)
                ax.plot(x_values_sorted, y_values_sorted, label=method_name, marker='o', linestyle='-')
            else:
                 print(f"No valid points.")

        ax.set_title(f'{dataset_name}')
        ax.set_xlabel('Recall 10@10')
        ax.set_xlim(min_recall, 1.01)
        ax.set_ylabel('Throughput (Op/s)')
        ax.grid(True)
        ax.legend()

    plt.tight_layout()
    return fig
